"""
예산을 할당한다.
정해진 총액 아래에서, 가능한 한 최대의 예산을 다음과 같은 방법으로 할당한다.
1. 모든 요청이 배정 가능한 경우, 요청한 그대로 배정한다.
2. 모든 요청이 배정할 수 없는 경우, 특정한 정수 상한액을 계산하여 그 이상인 예산 요청에는 모두 상한액을 배정
상한액 이하의 예산 요청액은 그대로 배정

budgets = [120, 110, 140, 150] 이고 전체 국가 예산이 485 인 경우:
상한액을 127로 잡으면 위의 요청에 대해 각각 120, 110, 127, 127을 배정하게 된다.
그럼 그 합이 484로, 가능한 최대가 된다.

이분탐색이란, 정렬된 배열 안에서 left 와 right 의 중간인 mid 의 값과 target값을 비교하면서
그 target값의 index를 찾아내는 것이다.

최대값은 budgets에서 가장 큰 값이 될 것이고, 최소값은 0이 된다.
즉, 0 ~ 150 사이의 정수 중에서 주어진 총 예산 M보다 작으면서, 가장 많은 예산을 할당하는 값을
찾아내는 것이 목표이다.

1번째: 0 ~ 150 구간
이 경우, 75가 상한액 후보로 나온다.
75 * 4  = 300 < 485 이므로, 75 + 1 을 left로 하고, right는 그대로 둔다.

2번째; 76 ~ 150 구간
이 경우, 113 이 상한액 후보로 나온다.
그리고 신청 예산 중, 113 보다 작은 110 이 있으므로, 이 값이 상한값인지 확인하기 위한 식은
다음과 같다.
110 + 113 * 3 = 449 < 485
후보 상한값 113 역시 아직 더 추가할 수 있다. 따라서, 114를 left로, 150을 right로 한다.

3번째: 114 ~ 150 구간
이 경우, 132 가 상한액 후보로 나온다.
132 보다 작은 예산이 2개가 있다. 그러므로, 이 값이 상한인지를 아래 식을 통해 확인한다.
110 + 120 + 132 * 2 = 494 > 485
즉, 상한 후보인 132는 너무 큰 값이다. 따라서, right를 131로 하고, left는 그대로 둔다.

4번째: 114 ~ 131 구간
이 경우, 122가 상한 후보로 나온다.
122 보다 작은 값이 2개가 있다. 그러므로, 아래 식을 보자
110 + 122 + 122 * 2 = 474 < 485
즉, 상한 후보 122는 아직 작다. 그러므로, left를 123으로 하고, right를 그대로 둔다

5번째: 123 ~ 131 구간
이 경우, 127이 상한 후보로 나온다.
127보다 작은 값이 2개가 있다. 아래 식을 보면
110 + 120 + 127 * 2 = 484 < 485
작다. 그럼 left를 128로 하고, right를 그대로 둔다.

6번째: 128 ~ 131 구간
이 경우, 129이 나온다.
110 + 120 + 129 * 2 = 488로, 총 예산보다 크다.
따라서, left를 128로 두고, right를 128로 한다.

7번째: 128 ~ 131 구간
이 경우, 129이 나온다.
그러면 식은 110 + 120 + 129 * 2 = 488 인데, 이 값은 485보다 크다.
따라서, left를 로 두고, right를 128로 둔다.

8번째: 128 ~ 128 구간
이 경우, 128이 나온다.
110 + 120 + 128 * 2 = 486인데, 485보다 크다.
따라서, left는 128 이고, right는 127이 된다.

"""


def solution(budgets, M):
    left = 0
    right = max(budgets)
    temp = 0
    answer = 0

    # print("right: ", right)
    # print("left: ", left, "\n")

    while right >= left:
        print("\nleft: ", left)
        print("right: ", right)
        mid = (left + right) // 2
        result = 0
        print("mid: ", mid)

        # budget 배열을 순회한다.
        for i in budgets:
            # left와 right의 중간인 mid의 값과 budget의 i번째 원소를 비교한다.
            # 만약 mid가 budget[i]보다 크다면
            # result에 i를 더한다.
            if mid > i:
                result += i

            else:
                result += mid

        print("result: ", result)

        if result > M:
            right = mid - 1
            # print("right: ", right)

        # result가 M보다 같거나 작은 경우
        else:
            # result가 temp보다 큰 경우
            answer = mid
            print("answer: ", answer)
            left = mid + 1
            
    return answer


budgets = [120, 110, 140, 150]
m = 485
print(solution(budgets, m))