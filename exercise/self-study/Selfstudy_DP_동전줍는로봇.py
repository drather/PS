"""
N * M 보드의 셀에, 몇 개의 동전이 놓여있을 때, 로봇이 좌측 상단부터 우측 하단까지 내려오면서 가장 많은 동전을 줍도록 하는 문제
- 각 스텝에서, 로봇은 우측 또는 하단으로만 움직일 수 있다.
- 각 단계에서, 위쪽에서 내려오는 경우와 왼쪽에서 오른쪽으로 가는 경우, 2가지의 값을 해당 셀에 저장한다.
- 즉, board[i][j]를 구한다 하면, board[i-1][j], board[i][j-1] 둘 중 큰 값 + 1 을 board[i][j]에 저장한다
- 그러고나서, board[n-1][m-1]의 값을 리턴한다.

입럭: N * M 의 2차원 배열 Baord
출력: 가장 많이 동전을 줍는 경우에서 동전의 갯수
"""

n = 6
m = 5
board = [[0,0,0,0,1,1], [0,1,0,1,0,0], [0,0,0,1,0,1], [0,0,1,0,0,1], [1,0,0,0,1,0]]
dp = []

for i in range(1, len(board)):
    for j in range(1, len(board[i])):
        print(j, "번째 열")
        board[i][j] = max(board[i-1][j], board[i][j-1]) + board[i][j]

print(board[-1][-1])