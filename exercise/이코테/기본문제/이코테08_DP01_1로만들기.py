"""
점화식을 구한다.
2 부터 num 까지 1씩 증가하며 루핑을 돈다.

각 인덱스 n의 값을 결정하는 것은 다음 항의 값이다.
- 바로 이전 항
- n 이 2로 나누어 떨어질 경우, n // 2 인 항
- n 이 3로 나누어 떨어질 경우, n // 3 인 항
- n 이 5로 나누어 떨어질 경우, n // 5 인 항

저 값 중 최소인 값을 찾아야 한다. 따라서, 다음 점화식을 따르다.
- 2로 나누어 떨어지는 경우
a[n] = min( a[n-1] + 1, a[n//2] + 1)

- 3로 나누어 떨어지는 경우
a[n] = min( a[n-1] + 1, a[n//3] + 1)

- 5로 나누어 떨어지는 경우
a[n] = min( a[n-1 + 1], a[n//5] + 1)

min() 함수 내부에서, 2번째 파라미터에 1을 더해주는 것은,
예를 들어, 4번째 항의 값을 구할 때, 이 값의 결정에 대해 관여하는 것은 바로 이전인 3번째 항의 값과, 4를 2로 나눈 몫인 2번째 항의 값이다.
따라서, 3번째 항의 값과 2번째 항 의 값 중 작은 값에 1을 더한 값을 4번째 항의 값으로 하는 것이다.

아래 코드에서는, d[n] = d[n] + 1 을 무조건 하고 시작하는데, 이는 a[n-1] + 1 은 2, 3, 5 로 나누어떨어지든 말든 공통이기 때문이다.
"""


# num = int(input())
num = 26


if __name__ == '__main__':
    d = [0] * 50000

    for i in range(2, num+1):
        d[i] = d[i-1] + 1

        if i % 2 == 0:
            d[i] = min(d[i], d[i // 2] + 1)

        if i % 3 == 0:
            d[i] = min(d[i], d[i // 3] + 1)

        if i % 2 == 0:
            d[i] = min(d[i], d[i // 5] + 1)

    print(d[num])

