"""
점화식을 구하자

dp 배열을 생성한다.

dp 배열의 각 원소는, 해당 집까지 얻을 수 있는 최대의 식량의 수를 나타낸다.

dp 배열의 각 원소의 값을 결정하는 알고리즘을 이해해야 한다.
dp 배열의 n 번째 원소를 결정하는데 관여하는 값은, dp[n-1] , dp[n-2] + houses[n] 이다
즉, n 번째 집을 털까 말까 고민할 때 고려해야 할 요소가 저 2가지 라는 것이다.

dp[n-1] 은 이전 집까지 고려했을 때, 얻을 수 있는 최대 식량을 의미한다.
dp[n] 은 해당 집까지 고려했을 때, 얻을 수 있는 최대 식량을 의미하고, 구해야 하는 값이다.

이전 집을 털었다면 해당 집을 털 수 없으므로, dp[n-1] 값이 그대로 온다.
이전 집을 털지 않았다면, 해당 집을 털 수 있으므로, dp[n-2] + houses[n] 이 된다.

이 두 가지 값 중, 큰 것을 dp[n] 의 값으로 한다

이게 무슨 의미냐?
n 번째 이전에 원소들은 이미 자기 인덱스까지 고려했을 때, 최적의 값을 갖고 있다.
이제 n 번째 값을 구할 때, (n-2 번째 집을 터는 경우 식량 값 + n 번째 집이 가진 식량 값) 과 ( n번째 집을 털지 않고 n-1 번째 집을 털었을 때의 최대 값)
을 비교한다는 뜻이다.
첫 번째 경우는 n 번째 집을 터는 경우이고, 두 번째 경우는 n번째 집을 털지 않는 경우이다.
두 경우를 비교해서, 결과가 더 좋은 경우의 값을 해당 인덱스의 값으로 한다.

좀 더 일반화 하자면, dp 를 이용해 문제를 풀 때,
- 고려해야 하는 요소가 무엇인지를 생각해서 ( 그러러면 점화식을 구해야 한다)
- 해당 인덱스에 값을 구하는 몇 가지 경우를 만들어 낸다.
- 그 후 해당 경우 중 가장 목적에 맞는 경우를 해당 값으로 선택한다.

"""

# houses = list(map(int, input().split()))
houses = [1, 3, 1, 5]


if __name__ == '__main__':
    dp = [0] * len(houses)
    dp[0] = houses[0]

    for i in range(1, len(houses)):
        if i == 1:
            dp[i] = max(houses[i], dp[i-1])

        else:
            dp[i] = max(dp[i-1], dp[i-2] + houses[i])

    print(dp[-1])